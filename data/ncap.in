// $Header: /data/zender/nco_20150216/nco/data/ncap.in,v 1.11 2002-01-19 20:05:56 hmb Exp $
// Purpose: ncap netCDF Arithmetic Processor Demonstration/Test Script
// Format of a valid ncap script:
// C++ comment syntax
// Statements end with semi-colons
// Usage:
// ncap -O -d lat,0 -d lon,0 -d lev,0 -D 1 -s "a9=three_dmn_var;" ${HOME}/nco/data/in.nc ${HOME}/nco/data/foo.nc
// ncap -O -D 1 -s "a8[lat,lon,lev] = 1;" ${HOME}/nco/data/in.nc ${HOME}/nco/data/foo.nc
// ncap -O -D 1 -S ${HOME}/nco/data/ncap.in ${HOME}/nco/data/in.nc ${HOME}/nco/data/foo.nc
// ncks -H -v -m ${HOME}/nco/data/foo.nc | m
//
//
// Can use ncap as an attribute editor 
// ----------------------------------
//
// Examples of using the -s switch 
//
// Define a new attribute 
// ncap -s "one@new = 2*att_var@double_att" in.nc foo.nc
//
// Re-define an attribute to be the square of itself 
// ncap -s "att_var@double_att = att_var@double_att^2.0" in.nc foo.nc
//
// Can have mixed types in RHS expression- Final result is converted to "highest type"
// ncap -s "one@new = att_var@short_att * att_var@double_att - att_var@double_att" in.nc foo.nc 
//
// Can use maths functions ( in this case the result is of type double)
// ncap -s "one@new = cos(1E-4) - 1" in.nc foo.nc
//
// Result is now of type float
// ncap -s "one@new = cos(1E-4f)^2 + sin(1E-4f)^2" in.nc foo.nc
//
// Can assign strings to attributes( Have to use \" to escape the quote from the shell) 
// ncap -s "one@new=\"hello world\"" in.nc foo.nc
//
// Can also add strings - and use escape chars e.g
// ncap -s "one@new=\"Hello\t\" + \"World\n\"" in.nc foo.nc
//
// Can let an attribute equal a 0-Dimensional variable
// ncap -s "one@new=one" in.c foo.nc
//
// Can let an attribute equal a 1-Dimensional variable
// ncap -s "one@new=mss_val" in.nc foo.nc 
//
// Variables
// ---------
//
// Multiply a co-ordinate variable by 20 
// ncap -s "lat=20*lat" in.nc foo.nc
//
// Do an "ensemble average" of variables of mixed types - result is of type double 
// ncap -s "average=(three_dmn_rec_var+three_dmn_var_dbl+three_dmn_var_int)/3" in.nc foo.nc
//
// Take the log(to base e) of the absolute value of a variable
// ncap -s "abslog=log(abs(three_dmn_var_dbl))" in.nc foo.nc
//
//The available maths functions are:  
// acos(); asin(); atan(); cos(); exp(); gamma(); log(); log10(); sin(); sqrt(); tan();
// If variable or attribute  is "less" than type float then the result is type float
// If variable or attribute is type double then result is double
// This also applies to the pow() function 
// Usage e.g pow(var1,3.5) or var1^3.5 
// e.g
// ncap -v -s "modulus=pow(sin(three_dmn_rec_var),2) + cos(three_dmn_rec_var)^2 - 1" in.nc foo.nc
//
// The modulus operator % can also be used with attributes and variable.
// In an operation involving an attribute and a variable the
// attribute is converted to the variable's type prior to the operation
// mod is of type int
// ncap -v -s "mod = three_dmn_rec_var % 4.0" in.nc foo.nc
//
// In this case mod is of type float
// ncap -v -s "testa = three_dmn_var_int - 1.0f" in.nc foo.nc
//
// Can also use UNARY +/- with an attribute or variable e.g.
// ncap -v -s "sign = -three_dmn_rec_var" in.nc foo.nc
//
//
//
//
// Charlie's Tests:
// p=hyam*PO + hybm*PS
a1 = hyam;
a2 = P0;
a3 = hybm;
a4 = PS;
a5 = hyam*P0;
//a6 = hybm*PS;
a7 = (1*(three_dmn_var-three_dmn_var+1)-1)^1;
a1@a1 = global@history;
a1@julian_day = global@julian_day;
//prs_mdp = P0*hyam + hybm*PS; // Fails because prs_mdp gets wrong rank
//prs_mdp = (three_dmn_var-three_dmn_var+1)*P0*hyam + (three_dmn_var-three_dmn_var+1)*hybm*PS; // Should work because prs_mdp is typecast
//prs_mdp_crd = (three_dmn_var_crd-three_dmn_var_crd+1)*P0*hyam + hybm*(three_dmn_var_crd-three_dmn_var_crd+1)*PS; // Should work because prs_mdp is typecast

// Henry's tests:
one@one=10+30;
one@two=sin(3.141/2);
one@three=cos(3.1415926)+one@one+one@two;
// It's OK to redefine attributes 
one@one=23/4;
one@two=one@one+one@two;
one@eight=25.0%4.99;
one@nine=1.e10;
one@ten=val_half_half@missing_value%1000;
// Standard netCDF postfix operators are used to define the attributes/numbers
// floats and doubles must include a decimal point or an exponent to be recognizied
one@byte=10b;
one@short=10s;
one@float=100.e2f;
one@double=2e3;
// Type conversion follows C rules: expression is converted to highest type
// Below expression is of type float
one@add = one@byte+one@short/one@float;
// can create a O dimensional variable 
nine=10000e2f;
one=10;
two=4;
val_half_half@missing_value = 21;
// Can use modulus operator with attributes and variables 
twenty = four_dmn_rec_var % 8; 
twentyone=sin(twenty)^2 + cos(twenty)^2;
twentytwo=10*9;
twentythree=1.e9%2;
twentyfour = two_dmn_var@units;
twentyfive=three_dmn_var_dbl/4;
twentysix=pck;
// Below multiplication is of individual elements in variables AND NOT
// a matrix multiplication. Resulting matrix is of type double.
twentyseven= three_dmn_var_int * three_dmn_var_dbl;
// atostr converts attribute to string, with an optional field for format
twenty@one = atostr(1.e10);
twenty@two = atostr(1/7.0);
twenty@three = atostr(1/7.0,"\t%15f\n");
// Can add two strings together
twenty@four = "Hello"+"\t World\n";
// Can put a 0 or 1 dimensional variable into an attribute
twenty@five= fl_nm;
twenty@six = mss_val;
twenty@seven=one;
// can use a UNARY -/+ and brackets
three= (-two_dmn_var + 5)^3;
testa= pow(sin( four_dmn_rec_var), 2) + cos(four_dmn_rec_var )^ 2 ;






