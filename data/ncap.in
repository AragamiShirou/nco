// $Header: /data/zender/nco_20150216/nco/data/ncap.in,v 1.13 2002-01-22 08:54:46 zender Exp $  -*-C-*-

// Purpose: ncap netCDF Arithmetic Processor Demonstration/Test Script

/* Format of valid ncap script:
   C or C++ comment syntax, most other syntax is C-like
   Statements must be terminated with semi-colons
   Whitespace (blank lines, tabs) is ignored */

/* Usage:
   ncap -O -d lat,0 -d lon,0 -d lev,0 -D 1 -s "a9=three_dmn_var;" ${HOME}/nco/data/in.nc ${HOME}/nco/data/foo.nc
   ncap -O -D 1 -s "a8[lat,lon,lev] = 1;" ${HOME}/nco/data/in.nc ${HOME}/nco/data/foo.nc
   ncap -O -D 1 -S ${HOME}/nco/data/ncap.in ${HOME}/nco/data/in.nc ${HOME}/nco/data/foo.nc
   ncks -H -v -m ${HOME}/nco/data/foo.nc | m */

/* Can use ncap as an attribute editor:
   Define new attribute 
   ncap -s "one@new = 2*att_var@double_att" in.nc foo.nc */

// Re-define attribute to square of itself 
// ncap -s "att_var@double_att = att_var@double_att^2.0" in.nc foo.nc

// Can have mixed types in RHS expression--final result is promoted to highest precision
// ncap -s "one@new = att_var@short_att * att_var@double_att - att_var@double_att" in.nc foo.nc 

// Can use maths functions (default result is of type double)
// ncap -s "one@new = cos(1.0e-4) - 1" in.nc foo.nc

// Result is now of type float
// ncap -s "one@new = cos(1.0e-4f)^2 + sin(1.0e-4f)^2" in.nc foo.nc

// Can assign strings to attributes( Have to use \" to escape the quote from the shell) 
// ncap -s "one@new=\"hello world\"" in.nc foo.nc

// Can also add strings - and use C escape chars, e.g,
// ncap -s "one@new=\"Hello\t\" + \"World\n\"" in.nc foo.nc

// Can let an attribute equal a 0-Dimensional variable
// ncap -s "one@new=one" in.c foo.nc

// Can let an attribute equal a 1-Dimensional variable
// ncap -s "one@new=mss_val" in.nc foo.nc 

/* Variables
   ---------
   Multiply a co-ordinate variable by 20 
   ncap -s "lat=20*lat" in.nc foo.nc */

// Average variables of mixed types (result is of type double)
// ncap -s "average=(three_dmn_rec_var+three_dmn_var_dbl+three_dmn_var_int)/3" in.nc foo.nc

// Take log (to base e) of absolute value of variable
// ncap -s "abslog=log(abs(three_dmn_var_dbl))" in.nc foo.nc

/* Available maths functions are:  
   acos(); asin(); atan(); cos(); exp(); gamma(); log(); log10(); sin(); sqrt(); tan();
   If argument precision is "less" than type float then result is type float
   If argument is type double then result is also double
   This also applies to pow() function, e.g, pow(var1,3.5) or var1^3.5, e.g.,
   ncap -v -s "modulus=pow(sin(three_dmn_rec_var),2) + cos(three_dmn_rec_var)^2 - 1" in.nc foo.nc */

/* Modulus operator % can also be used with attributes and variables
   Attributes are converted to variable's type prior to operation
   mod is of type float
   ncap -v -s "mod = three_dmn_rec_var % 4.0" in.nc foo.nc */

// In this case mod is of type int
// ncap -v -s "testa = three_dmn_var_int - 1.0f" in.nc foo.nc

// Can also use UNARY +/- with an attribute or variable e.g.
// ncap -v -s "sign = -three_dmn_rec_var" in.nc foo.nc

// Charlie's Tests:
// p=hyam*PO + hybm*PS
a1 = hyam;
a2 = P0;
a3 = hybm;
a4 = PS;
a5 = hyam*P0;
//a6 = hybm*PS;
a7 = (1*(three_dmn_var-three_dmn_var+1)-1)^1;
a1@a1 = global@history;
a1@julian_day = global@julian_day;
//prs_mdp = P0*hyam + hybm*PS; // Fails because prs_mdp gets wrong rank
//prs_mdp = (three_dmn_var-three_dmn_var+1)*P0*hyam + (three_dmn_var-three_dmn_var+1)*hybm*PS; // Should work because prs_mdp is typecast
//prs_mdp_crd = (three_dmn_var_crd-three_dmn_var_crd+1)*P0*hyam + hybm*(three_dmn_var_crd-three_dmn_var_crd+1)*PS; // Should work because prs_mdp is typecast

// Henry's tests:
one@one=10+30;
one@two=sin(3.141/2);
one@three=cos(3.1415926)+one@one+one@two;
// It's OK to redefine attributes 
one@one=23/4;
one@two=one@one+one@two;
one@eight=25.0%4.99;
one@nine=1.e10;
one@ten=val_half_half@missing_value%1000;
// Standard netCDF postfix operators are used to define the attributes/numbers
// floats and doubles must include a decimal point or an exponent to be recognizied
one@byte=10b;
one@short=10s;
one@float=100.e2f;
one@double=2e3;
// Type conversion follows C rules: expression is converted to highest type
// Below expression is of type float
one@add = one@byte+one@short/one@float;
// can create a O dimensional variable 
nine=10000e2f;
one=10;
two=4;
val_half_half@missing_value = 21;
// Can use modulus operator with attributes and variables 
twenty = four_dmn_rec_var % 8; 
twentyone=sin(twenty)^2 + cos(twenty)^2;
twentytwo=10*9;
twentythree=1.0e9%2;
twentyfour = two_dmn_var@units;
twentyfive=three_dmn_var_dbl/4;
twentysix=pck;
// Below multiplication is of individual elements in variables AND NOT
// a matrix multiplication. Resulting matrix is of type double.
twentyseven= three_dmn_var_int * three_dmn_var_dbl;
// atostr converts attribute to string, with an optional field for format
twenty@one = atostr(1.e10);
twenty@two = atostr(1/7.0);
twenty@three = atostr(1/7.0,"\t%15f\n");
// Can add two strings together
twenty@four = "Hello"+"\t World\n";
// Can put a 0 or 1 dimensional variable into an attribute
twenty@five= fl_nm;
twenty@six = mss_val;
twenty@seven=one;
// Can use a UNARY -/+ and brackets
three= (-two_dmn_var + 5)^3;
testa= pow(sin(four_dmn_rec_var),2) + cos(four_dmn_rec_var)^2;
