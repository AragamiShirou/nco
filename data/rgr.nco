// $Header: /data/zender/nco_20150216/nco/data/rgr.nco,v 1.4 2007-10-03 20:39:52 zender Exp $ -*-C++-*-

// Purpose: ncap script for linear and non-linear data regressions

/* Usage:
   ncap2 -v -O -D 1 -S ${HOME}/nco/data/rgr.nco ${HOME}/nco/data/in.nc ~/foo_rgr.nc
   ncks -C -H -F -u -v slp,fst,crr_cff ~/foo_rgr.nc */

/* Helpful discussion at:
   http://mathworld.wolfram.com/LeastSquaresFitting.html */

/* Ancillary simulations:
ncap2 -v -D 1 -O \
-s 'abc_nbr=5' \
-s 'defdim("sgn",abc_nbr)' \
-s 'sgn_mV[sgn]={4.52,8.90,15.66,22.41,37.86}' \
-s 'rfl[sgn]={9.43,25.68,46.67,65.23,98.5}' \
-s 'abc=sgn_mV;ord=rfl'
-s ''
-s 'defdim("x",6);flx_mss_vrt_dst_nrm_trc[$x]=flx_mss_vrt_dst_nrm(0:5)' \
-s 'flx_mss_vrt_dst_nrm_trc_nrm=flx_mss_vrt_dst_nrm_trc*(1.0-(0.17+0.67))/flx_mss_vrt_dst_nrm_trc.total()' \
-s 'flx_mss_vrt_dst_nrm_crc=flx_mss_vrt_dst_nrm' \
-s 'flx_mss_vrt_dst_nrm_crc(0:5)=flx_mss_vrt_dst_nrm_trc_nrm' \
-s 'flx_mss_vrt_dst_nrm_crc(6)=0.17' \
-s 'flx_mss_vrt_dst_nrm_crc(7)=0.67' \
-s 'flx_mss_vrt_dst_nrm_crc_ttl=flx_mss_vrt_dst_nrm_crc.total()' \
~/foo.nc ~/foo_rgr.nc # Normalize mass fractions
ncks -C -F -v slp,fst ~/foo_rgr.nc # Answers
ncks -C -F -s "%8.3e, " -v slp,fst ~/foo_rgr.nc # Answers formatted */

pi=3.1415926535897932384626433832795029L; // (3.1415926535897932384626433832795029L) [frc] 3
pi@long_name="Pi";
pi@units="fraction";

rgr_qdr=0s; // [flg] Quadratic fit
rgr_lnr=1s; // [flg] Linear fit

// Choose PSD
rgr_typ=rgr_lnr; // [enm] Regression type

if(rgr_typ==rgr_lnr){
  abc_nbr=5; // [nbr] Number of abscissae
  defdim("sgn",abc_nbr); // [nbr] Measurement dimension
  // Visible Channel 635 nm
  // sgn_mV[sgn]={}; // [mV] Signal
  // rfl[sgn]={}; // [frc] Reflection
  // NIR Channel 1310 nm
  sgn_mV[sgn]={4.52,8.90,15.66,22.41,37.86}; // [mV] Signal
  rfl[sgn]={9.43,25.68,46.67,65.23,98.5}; // [frc] Reflection

  // Assign generic names for mathematics
  abc=sgn_mV;
  ord=rfl;
}else if(rgr_typ==rgr_qdr){
  abc_nbr=5; // [nbr] Number of abscissae
} // !rgr_typ

abc_avg=abc.avg(); // [] Abscissa average
ord_avg=ord.avg(); // [] Ordinate average
ss_xx=((abc-abc_avg)^2).total(); // [] Sum of squares of deviations from mean abscissa
ss_yy=((ord-ord_avg)^2).total(); // [] Sum of squares of deviations from mean ordinate
ss_xy=((abc-abc_avg)*(ord-ord_avg)).total(); // [] Covariance
var_x=ss_xx/abc_nbr; // [] Variance of abscissae
var_y=ss_yy/abc_nbr; // [] Variance of ordinates
slp=ss_xy/ss_xx; // [] Slope
fst=ord_avg-slp*abc_avg; // [] Offset
crr_cff_sqr=ss_xy*ss_xy/(ss_xx*ss_yy); // [] Variance explained
crr_cff=sqrt(crr_cff_sqr); // [] Correlation coefficient
ord_prd=fst+slp*abc; // [] Ordinates predicted by regression

ss_xx@long_name="Sum of squares of deviations from mean abscissa";
ss_yy@long_name="Sum of squares of deviations from mean ordinate";
ss_xy@long_name="Covariance";
var_x@long_name="Variance of abscissae";
var_y@long_name="Variance of ordinates";
slp@long_name="Slope";
fst@long_name="Offset";
crr_cff_sqr@long_name="Variance explained";
crr_cff@long_name="Correlation coefficient";

rfl@long_name="Reflectance";
rfl@units="fraction";

sgn_mV@long_name="Signal in millivolts";
sgn_mV@units="millivolt";

sgn=1.0e-3*sgn_mV; // [V] Signal
sgn@long_name="Signal";
sgn@units="volt";


