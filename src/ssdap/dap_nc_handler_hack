#!/usr/bin/env python
import getopt, os, shlex, sys, tempfile, shutil
import re, string, time
import md5
       
       
# $Id: dap_nc_handler_hack,v 1.24 2006-03-09 22:30:40 wangd Exp $
# This is:  -- a wrapper-replacement for dap_nc_handler used by opendap.
#           -- It provides a script handling facility, but redirects most
#              normal calls to the original dap_nc_handler

# we potentially have to handle: das, dds, dods, ascii, info
# das -- ??
# dds -- ??
# dods -- return dods data. This is the one we care about.
# ascii -- does dods mode, with -e and no url
# info -- does das/dds sequence
# html -- calls das/dds to obtain var info, then gives html form
# version -- doesn't seem to call the handler: opendap core version

#options: -o <response>: DAS, DDS, DataDDS, DDX, BLOB or Version (Required)
#          -u <url>: The complete URL minus the CE (required for DDX)
#          -c: Compress the response using the deflate algorithm.
#          -e <expr>: When returning a DataDDS, use <expr> as the constraint.
#          -v <version>: Use <version> as the version number
#          -d <dir>: Look for ancillary file in <dir> (deprecated).
#          -f <file>: Look for ancillary data in <file> (deprecated).
#          -r <dir>: Use <dir> as a cache directory
#          -l <time>: Conditional request; if data source is unchanged since
#                     <time>, return an HTTP 304 response.
#
#          -L : skip printing of http headers. **** for easier testing
#
######################################################################
# Administrator-tunable parameters:
######################################################################
class local:
    disableLogging = False
    logLocation = "/var/log/ssdap.log"

    #ncBinPath = os.environ["MY_BIN_DIR"]
    nc4BinPath = "/usr/local/bin"
    ncDapBinPath = "/usr/local/bin"

    # pass original DAP commands to the original dap handler.
    passthroughPath = "/usr/local/bin/dap_nc_handler"

    disableHTTP = True # Recommend: True (until client code is fix'd)
    # this is for command-line debugging

    disableParallel = True


######################################################################
# User/Administrator notes:
######################################################################
# this script switches between using DAP-aware or NetCDF4-capable NCO
# binaries depending on if an OPeNDAP url is detected in a script
# line. An opendap url is currently detected by looking for an
# http:// prefix.
#



######################################################################
# this class should stay identical in client/server.  If it gets big,
# we should split it into some python module to be imported.
class SsdapCommon:
    """stuff that should be identical between client and server code"""
    parserShortOpt = "4AaBb:CcD:d:FfHhl:Mmn:Oo:Pp:QqRrs:S:s:t:uv:w:xY:y:"
    parserLongOpt = ["4", "netcdf4", "apn", "append",
                     "abc", "alphabetize", "bnr", "binary",
                     "fl_bnr=", "binary-file=",
                     "crd", "coords",
                     "nocoords", "dbg_lvl=", "debug-level=",
                     "dmn=", "dimension=", "ftn", "fortran",
                     "huh", "hmm",
                     "fnc_tbl", "prn_fnc_tbl", "hst", "history",
                     "Mtd", "Metadata", "mtd", "metadata",
                     "lcl=", "local=",
                     "nintap",
                     "output=", "fl_out=",
                     "ovr", "overwrite", "prn", "print", "quiet",
                     "pth=", "path=",
                     "rtn", "retain", "revision", "vrs", "version",
                     "spt=", "script=", "fl_spt=", "script-file=",
                     "sng_fmt=", "string=",
                     "thr_nbr=", "threads=", "omp_num_threads=",
                     "xcl", "exclude",
                     "variable=", "wgt_var=", "weight=", 
                     "op_typ=", "operation=" ]

    # special handling for ncap's parameters
    ncapShortOpt = parserShortOpt.replace("v:","v")
    ncapLongOpt = parserLongOpt[:]
    ncapLongOpt.remove('variable=')
    ncapLongOpt.append('variable')

    ncpdqShortOpt = parserShortOpt.replace("a","a:")
    ncpdqShortOpt = ncpdqShortOpt.replace("M","M:")
    ncpdqShortOpt = ncpdqShortOpt.replace("P","P:")
    ncpdqShortOpt = ncpdqShortOpt.replace("u","Uu")
    
    ncpdqLongOpt = parserLongOpt[:]
    ncpdqLongOpt.extend(['arrange','permute','reorder', 'rdr',
                         'pck_map', 'map', 'pck_plc','pack_policy',
                         'upk', 'unpack'])

    @staticmethod
    def specialGetOpt(cmd, argvlist):
        #consider special-case for ncwa ncflint -w: option
        # wgt_var, weight also for ncflint/ncwa
        if cmd == "ncap": # ncap has a different format
            return getopt.getopt(argvlist,
                                 SsdapCommon.ncapShortOpt,
                                 SsdapCommon.ncapLongOpt)
        elif cmd == "ncpdq": # ncpdq has a different format too
            return getopt.getopt(argvlist,
                                 SsdapCommon.ncpdqShortOpt,
                                 SsdapCommon.ncpdqLongOpt)            
        else:
            return getopt.getopt(argvlist,
                                 SsdapCommon.parserShortOpt,
                                 SsdapCommon.parserLongOpt)
    pass

############################################################
# config file reader

def readConfigFile(fname = "ssdap_handler.conf"):
    # can add other mappings from config file to local settings"
    # set some defaults.
    # form: (local varname, section, item, defaultvalue)
    cfgmap = [("disableLogging", "log", "disable", False),
              ("logLocation",    "log", "location",
               "/home/wangd/opendap/iroot/ssdap.log"),
              ("nc4BinPath", "targets", "netcdf4nco",
               "/home/wangd/opendap/iroot/nco_ncdf4_bin"),
              ("ncDapBinPath", "targets", "opendapnco",
               "/home/wangd/opendap/iroot/nco_dap_bin"),
              ("passthroughPath", "targets", "passthroughPath",
               "/home/wangd/opendap/iroot/bin/dap_nc_handler"),
              ("disableHTTP", "global", "disableHTTP", True),
              ("disableParallel", "global", "disableParallel", True) ]
    remap = {"True" : True, "False" : False, "Yes" : True, "No" : False }


    try:
        import ConfigParser
        config = ConfigParser.ConfigParser()
        if len(os.path.split(fname)[0]) == 0:
            # look in the same place as the script is located...
            # should I check current working directory instead?
            filepath = os.path.join(os.path.split(sys.argv[0])[0],
                                    fname)
        else: filepath = fname
        config.read(filepath)
        for m in cfgmap:
            if config.has_option(m[1], m[2]):
                val = config.get(m[1],m[2])
                if val in remap: val = remap[val]
                setattr(local, m[0], val)
                # uncomment if you are curious about cfgfile reading
                #logit("cfgfile: setting local." + m[0] + " " +str( val))

        # dump entire config file (to remember the interface)
        #for section in config.sections():
        #    print section
        #    for option in config.options(section):
        #        print " ", option, "=", config.get(section, option)
        ScriptingEnv.fixConfig()
        pass
    except AttributeError:
        # no config file, probably safe to silently ignore
        pass

######################################################################
# setup some logging
######################################################################
def prestartLogging():
    """start logging using a fake file.  Dump contents to a real log after
    the log file location is decided."""
    local.mypid = os.getpid()
    if not local.disableLogging:
        import cStringIO
        local.logfile = cStringIO.StringIO()
        p = str(local.mypid)
        local.logfile.write("handler "+p+" log open at " + time.ctime()+"\n")
def startLogging():
    if not local.disableLogging:
        lastcontents = local.logfile.getvalue()
        local.logfile = open(local.logLocation, "a")
        local.logfile.write(lastcontents)
        #local.logfile.write("log located at " + local.logLocation + "\n")

def logit(s):
    if not local.disableLogging:
        local.logfile.write(str(local.mypid)+"=="+s+"\n")
    #print s
def logflush():
    if not local.disableLogging:
        local.logfile.flush()
    pass

######################################################################
class Command:
    """The Command class is an abstraction for a single script command
    to be executed.  Each line in the script line maps to approximately
    one command.  The Command class depends on the scripting environment
    to provide constants in generating a command line."""
    def __init__(self, line, scriptenv):
        self.original = line
        self.env = scriptenv
        self.cmdLine = None #empty commmandline for now
        self.myName = ""
        self.cmd = None
        self.dependents = []
        self.ancestors = []
        self.absOutputs = []
        self.absInputs = []
        self.inPrefix = ""
        self.saveOutput = False
        self.popen = os.popen2

        self.parseOriginalLine()
        self.buildCommandLine()
        pass

    def commandLine(self):
        return self.cmdLine
    def addChild(self, comm):
        assert isinstance(comm, Command)
        # update self
        if comm not in self.dependents:
            self.dependents.append(comm)
        #update child
        if self not in comm.parents():
            comm.addParent(self)
    def addParent(self, comm):
        assert isinstance(comm, Command)
        # update self
        if comm not in self.ancestors:
            self.ancestors.append(comm)
        # update parent
        if self not in comm.children():
            comm.addChild(self)

    def children(self):
        return self.dependents
    def parents(self):
        return self.ancestors
    def outputs(self):
        """ return a list of absoutputfiles """
        return self.absOutputs
    def inputs(self):
        """ return a list of absinputfiles """
        return self.absInputs


    # "private" functions

    def parseOriginalLine(self):

        argv = shlex.split(self.original)

        if len(argv) < 1:
            return # nothing to parse

        mycmd = argv[0]
        if mycmd[0] == "#": #comment: nothing to parse.
            return
        valids = ScriptingEnv.META_COMMANDS + ScriptingEnv.NCO_COMMANDS
        if mycmd not in valids:
            print "WARN: bad script line: " + self.original
            return
        self.myName = mycmd + str(len(self.env.commands))
        self.cmd = mycmd

        if self.cmd in ScriptingEnv.META_COMMANDS:
            self.parseMetaCmd(argv[1:])
        else:
            self.parseNormalCmd(argv[1:])

    def parseMetaCmd(self, argv):
        metamap = {"ssd_initsave": self.cmdInitSave,
                   "ssd_save": self.cmdSave,
                   "ssd_poll": self.cmdPoll}
        metamap[self.cmd](argv)
        pass

    def parseNormalCmd(self, argv):
        try:
            (arglist, leftover) = SsdapCommon.specialGetOpt(self.cmd, argv)
        except getopt.GetoptError:
            import traceback
            logit("Error parsing(getopt) command: " + self.original)
            logit(traceback.format_exc())
            raise ValueError, 'Command.parse error'
        argdict = dict(arglist)
        self.acceptModifiers(argdict, arglist, leftover)
        self.acceptInOut(argdict, arglist, leftover)
        self.fixupDependencies()
        self.arguments = arglist
        pass

    def acceptModifiers(self, adict, alist, leftover):
        """accept special things like %stdouterr% and %stdout% so that
        specify how to handle a particular line."""
        def selectPopen2():
            self.popen = os.popen2
            self.absOutputs.append(ScriptingEnv.SCRIPT_STDOUT)
            self.saveOutput = True
        def selectPopen4():
            self.popen = os.popen4
            self.absOutputs.append(ScriptingEnv.SCRIPT_STDOUTERR)
            self.saveOutput = True
        # yes, I could replace the above with a single def that
        # generated the right function, but why bother?

        # this is a table of what can be matched, and what to do if
        # there's a match.
        redirTable = {ScriptingEnv.SCRIPT_STDOUTERR : selectPopen4,
                      ScriptingEnv.SCRIPT_STDOUT: selectPopen2}
        # check hangers-on on the tail of the line for modifiers.
        # for now, process last to first, until we get a lot of modifiers
        # and have a chance for actual conflict/precedence
        while leftover[-1] in redirTable:
            redirTable[leftover.pop()]()

            # pop off the back of the list, and then do the right thing.

    def acceptInOut(self, adict, alist, leftover):
        # look for output file first
        ofname = ""
        for x in  ["-o", "--fl_out", "--output"]:
            if x in adict:
                assert ofname == ""
                keys = [y[0] for y in alist]
                o = alist.pop(keys.index(x)) # o is a tuple.
                ofname = adict.pop(x)
                assert o[1] == ofname
                
        if ofname == "":
            # don't steal output if it's actually the input.
            if len(leftover) <= 1:
                # only one leftover...leave it to be captured by the inputter
                if len(self.absOutputs) == 0:
                    logit("warning, unbound output for " + self.original)
            else:
                ofname = leftover[-1] # take last arg
                leftover = leftover[:-1] # and drop it off

        if ofname != "": # should have a real filename (or placeholder)
            self.absOutputs.append(ofname)
        self.absInputs += leftover
        if "-p" in adict:
            self.inPrefix = adict["-p"]
            keys = [x[0] for x in alist]
            p = alist.pop(keys.index("-p"))
            adict.pop("-p")
        self.patchNcapInscript(adict,alist,leftover)
        pass
    
    def patchNcapInscript(self, adict, alist, leftover):
        """ncap is a special command that has an input script.
        If we are passed a filename, we should look for it in a particular
        place"""
        # this exists to solve:
        # what about server side script?  The 1st ncap regression calls
        # for the reading of a script from a file instead of supplying it
        # in the commandline.
        # ncap -h -O $fl_fmt $nco_D_flg -v -S ncap.in $in_pth_arg in.nc %tempf_00%";
        #                                  ^^^^^^^^^^
        # Can you capture/parse  the '-S scriptfile' and search for the
        # script file in the specified '-p dir'? 


        if "ncap" != self.cmd:
            return # exit if it's not ncap
        if "-S" in adict:
            newname = self.addInfilePrefix(adict["-S"])
            keys = [x[0] for x in alist]
            alist[keys.index("-S")] = ('-S', newname)
            adict["-S"] = newname
        pass
        
    def fixupDependencies(self):
        # go get a reversed list of the previous commands
        previous = self.env.commands[:] #make copy!
        previous.reverse() #reverse happens in-place

        # for each input, check previously parsed for RAW hazards
        # read-after-write is a true dependency
        for x in self.absInputs:
            for p in previous:
                if x in p.outputs():
                    p.addChild(self)
                    break # only choose most recent output

        # don't do the other checking until we decide to track those deps
        # for each output, check previously parsed for WAW hazards
        # write-after-write is an output dependency
        # also check for WAR: anti-dependency
        #for x in self.absOutputs: # probably only one output...
        #    for p in previous:

    def buildCommandLine(self):
        line = ""
        needsDap = False
        if self.cmd == None: # don't build cmdline for non-cmds
            return
        # prefix cmd at the end.
        #line += ScriptingEnv.VALID_COMMANDS[self.cmd]

        
        # pass options first
        for (k,v) in self.arguments:
            #special value handling for --op_typ='-'
            needsProt = False
            safe = string.letters + string.digits + "%"
            for x in v: needsProt |= (x not in safe)

            # add = for long options? is this necessary?
            k1 = k
            #if len(k) > 2: k1 = k + "="

            
            if needsProt and not ("'" == v[0] == v[-1]):
                line += " " + k1 + " '" + v + "'"
            elif len(v) > 0: line += " " + k1 + " " + v
            else:            line += " " + k1
        # then pass commands
        filelist = []
        for name in self.absInputs:
            filelist.append(name)
        for name in self.absOutputs:
            if name in [ ScriptingEnv.SCRIPT_STDOUTERR,
                         ScriptingEnv.SCRIPT_STDOUT ]:
                continue
            filelist.append(name)
        for name in filelist:
            if self.env.shouldRemap(name):
                remapped = self.env.addAbsName(name)
                assert remapped != None
                line += " " + remapped
            elif self.env.possibleFilename(name):
                # add defpath for now.
                newname = self.addInfilePrefix(name)
                line += " " + newname
            else:
                needsDap |= self.env.requiresDap(name)
                line += " " + name
        if needsDap:
            self.cmdLine = ScriptingEnv.VALID_DAPCOMMANDS[self.cmd] + " " + line
        else:
            self.cmdLine = ScriptingEnv.VALID_COMMANDS[self.cmd] + " " + line
        logit( "real cmdline: " + self.cmdLine)
        pass
    def addInfilePrefix(self, name):
        n = None
        if self.inPrefix: n = os.path.join(self.inPrefix,name)
        else: n = name                    
        return os.path.join(self.env.env["defpath"], n)
    
    def cmdInitAsync(self, argv):
        # want to close CGI connection, and then continue
        # Return a task id that can be queried later.
        tid = self.taskId()
        sys.stdout.flush() # flush output before forking
        try:
            of = os.fork()
        except OSError:
            sys.stderrwrite('fork failed\n')
            sys.exit(1)
        if of == 0: # child process
            # child does the real work.
            # set async: redirect stdout/stdin etc.
            # write stdout to task.id.stdout
            # when finished, write task.id.result
            self.env.setAsync()
            pass
            
        else: # parent process
            print "Your task id is", tid, "running with PID", of
            self.env.setAsync()
            # want to report task id and then exit.
            # this should let the client transaction finish
            pass
            
        
        pass
    def cmdSave(self, argv):
        # designate real filename (or just a persistently-mapped identifier)
        # that can be requested later.  Would like to put in normal
        # opendap-visible space.
        #FIXME
        pass
    def cmdPoll(self, argv):
        # check for job finish. check for task.id.result. if not exist,
        # consider reading task.id.stdout for fun.
        #FIXME
        pass

    def execute(self, scrEnv):
        """execute myself in a certain scripting environment"""
        # open question: is it better to pass functions than the whole object?
        # FIXME
        pass 
    
    def taskId(self):
        try: return self.cachedTaskId
        except:
            # get fingerprint from env
            digest = self.env.fingerprint()
            # munge the fingerprint to reduce clashes...
            # PIDs will be recycled, so this needs more work
            newdig = md5.md5(digest + str(os.getpid())).digest()
            # take first 4 bytes, convert to hex, strip off 0x and L
            taskid = hex(struct.unpack("L",newdig[:4])[0])[2:-1]
            self.cachedTaskId = taskid
            return self.cachedTaskId
        pass

######################################################################
class DepTracker:
    """DepTracker is a class that encapsulates logic that understands
    the concept of job readiness and dependencies"""

    # since python has "managed variables" we can add get/set
    # accessor/mutators later without disrupting client code

    #for now, runnableCmds is public
    def __init__(self, cmdlist):
        self.execList = cmdlist[:]
        self.nextCmdIndex = 0 # where are we in issuing jobs?
        self.completedCmds = [] # which jobs have completed?
        self.availableData = [] # which values are available?
        self.pendingCmds = []
        self.runnableCmds = []
        self.updateRunnable()
        pass

    def markCompleted(self, cmd):
        self.availableData.append(cmd.outputs)
        self.completedCmds.append(cmd)
        self.pendingCmds.remove(cmd)
        self.updateRunnable()
        pass

    def markRunning(self, cmd):
        assert cmd in self.runnableCmds
        self.pendingCmds.append(cmd)
        self.runnableCmds.remove(cmd)
        pass
    def done(self):
        """done means that all cmds have completed.  There are no jobs
        runnable or pending.  All results are available. completedCmds
        should have the same length as the original execList."""
        idle = (not self.pendingCmds) and (not self.runnableCmds)
        reallydone = len(self.execList) == len(self.completedCmds)
        return idle and reallydone
    # private
    def updateRunnable(self):
        elist = self.execList
        idx = self.nextCmdIndex
        cmd = elist[idx]
        while self.isRunnableCmd(cmd):
            self.runnableCmds.append(cmd)
            idx += 1
            cmd = elist[idx]
        self.nextCmdIndex = idx
        pass
    def isRunnableCmd(self, cmd):
        for i in cmd.inputs:
            if i not in self.availableData:
                return False
        return True

######################################################################
# This class should hold the state used by a single script
# Might be worthwhile to split out constants/data shared
#  between scripts instead of letting them be class shared data.
######################################################################
class ScriptingEnv:
    # constants (but not const-enforced by python)
    SCRIPT_OUTFILE = "%outfile%"
    SCRIPT_STDOUTERR = "%stdouterr%"
    SCRIPT_STDOUT = "%stdout%"
    # note that it's a bad idea to have outputfile set, and one of the
    # console output catchers as well.  you're on your own for
    # deciphering the file out of that mess.

    CLASS_TEMP = "tempf"
    CLASS_SEP = "_"
    MAGIC_DELIM = "%"
    NC_SUFFIX = ".nc"
    NCO_COMMANDS = ["ncap", "ncatted", "ncbo", "ncdiff",
            "ncea", "ncecat", "ncflint", "ncks",
            "ncpack", "ncpdq", "ncra", "ncrcat",
            "ncrename", "ncunpack", "ncwa"]
    # for now, all commands are valid in netcdf4 or over dap
    VALID_COMMANDS=dict((x, local.nc4BinPath+os.sep+x) for x in NCO_COMMANDS)
    VALID_DAPCOMMANDS=dict( (x, local.ncDapBinPath+os.sep+x) for x in NCO_COMMANDS)

    # room to add other commands here.
    META_COMMANDS = ["ssd_initsave", "ssd_save", "ssd_poll"]

    
    COMMENT_CHAR = "#"  # not used right now.

    def __init__(self, scriptlines, settingsDict):
        assert type(scriptlines) == type([])
        assert type(settingsDict) == type({})
        self.fileMap = {}
        self.env = settingsDict
        self.lines = scriptlines
        # save lines of output for each type of output.
        # direct child output to /dev/null unless requested
        #self.outFd = os.devnull
        #self.popen = os.popen2 ## let's deprecate this... FIXME!

        # make commandlines from each scriptline
        self.commands = []  # list of commands (inc. comments)
        #WARN: commands is read by the command builder
        self.commandLine = [] # list of commandlines (no comments)
        for line in scriptlines:
            c = Command(line, self)
            self.commands.append(c) # append command, regardless of parsing
            if c.commandLine() != None:
                #print c.commandLine()
                self.commandLine.append(c)

        logit(self.depTreeToString()) # for debug...

        pass
    @staticmethod
    def fixConfig():
        j = os.path.join
        c = ScriptingEnv.NCO_COMMANDS
        ScriptingEnv.VALID_COMMANDS=dict((x, j(local.nc4BinPath,x)) for x in c)
        ScriptingEnv.VALID_DAPCOMMANDS=dict( (x, j(local.ncDapBinPath,x)) for x in c)
        
    
    def shouldRemap(self, absName):
        # return bool indicating whether this word should be xlated.
        # keep simple for now: check a list.
        # first, filter out %...% delimiters
        if not (absName[0] == absName[-1] == ScriptingEnv.MAGIC_DELIM):
            return False  # do not remap these.
        symname = absName[1:-1] # clip ends
        fields = string.split(symname, ScriptingEnv.CLASS_SEP)
        if len(fields) == 2:
            # check for tempname
            if fields[0] == ScriptingEnv.CLASS_TEMP:
                return True
        return absName == ScriptingEnv.SCRIPT_OUTFILE
    def processSpecial(self, absName):
        """ don't use this anymore """
        return False
        # deprecate this way of tracking, in favor of a more general
        # system that can be more flexible and work with per-line modifiers.
        redirTable = {ScriptingEnv.SCRIPT_STDOUTERR : os.popen4,
             ScriptingEnv.SCRIPT_STDOUT: os.popen2}
        if absName in redirTable:
            self.outFd = sys.stdout
            self.popen = redirTable[absName]
            return True
        return False
    def possibleUrl(self, cand):
        """return a sre.SRE_Match object if input matches our primitive regex
        otherwise, return None"""
        return re.match('^\w+://', cand)

    def requiresDap(self, word):
        return word[:7] == 'http://'


    def possibleFilename(self, cand):
        # leave urls alone.
        if self.possibleUrl(cand): return False

        elts = string.split(cand, ".")

        if len(elts) != 2: #looking for something.ext
            return False
        if elts[1] != "nc": # only going to detect .nc
            return False
        if elts[0][0] == os.sep: # do not detect with leading /
            return False
        return True


    def addAbsName(self, absName):
        """ return a concrete name from an abstract name"""
        if self.fileMap.has_key(absName):
            return self.fileMap[absName][1] # reuse mapped name
        alnum = string.letters + string.digits
        fixName = ""
        for i in absName:
            if i in alnum: fixName += i

        filepair = tempfile.mkstemp( ScriptingEnv.NC_SUFFIX,
                        fixName,
                        self.env["tempdir"] )
        # filepair = (descriptor, tempfilename)
        self.fileMap[absName] = filepair
        # close the file, so the nco util can touch it
        os.close(filepair[0])
        return filepair[1]

    def execute(self):
        self.clearTemps()
        logflush()
        #print "about to execute..."
        for l in self.commandLine:
            #print l
            pass
        # check to make sure we don't have both an output file and outstderr
        # make sure we're doing exactly one thing with our output
        havefile = self.fileMap.has_key(ScriptingEnv.SCRIPT_OUTFILE)
        # outbypass = (self.outFd != os.devnull)
        # assert havefile ^ outbypass
        self.serialExec()
        pass
    
    def serialExec(self):
        for c in self.commandLine:
            self.runCmdRaw(c)
        pass
    def runCmdRaw(self, cmd):
        outFd = os.devnull
        if cmd.saveOutput == True:
            outFd = sys.stdout
        (sin,sout) = cmd.popen(cmd.commandLine())  # use the mapped popen
        sin.close() # close the input, so it flushes
        #out handle is now ready to be read.
        #for x in sout:
        #   self.outStream.append(x)
        #   logit( "execution output: " + x)
        # skip logging the output, and just dump to outstream.

        if outFd == os.devnull:
            fd = open(outFd, "w")
            shutil.copyfileobj(sout, fd)
            fd.close()
        else:
            shutil.copyfileobj(sout, outFd)

    def depExec(self):
        """an in-order multi-issue(not yet!) command scheduler"""
        dept = DepTracker(self.commandLine) # track deps
        while not dept.done():
            # assume infinite issue width for now
            while dept.runnableCmds:
                cmd = dept.runnableCmds[0]
                dept.markRunning(cmd)
                # run/spawn cmds
                self.runCmdRaw(cmd)
                dept.markCompleted(cmd)
            # check for completed jobs. how?
            
            
            #here, we should sleep, since there are no runnable cmds
            #before we check again for runnables.
            time.sleep(1)
        #we should be done
        
    def spawnProcess(self):
        """run a command, capture its output in??? FIXME"""
        pass
    
    def depTreeToString(self):
        out = "Script dependency digraph: \n"
        for x in self.commands:
            for c in x.children():
                # find shared input and output
                inputs = c.inputs()
                for o in x.outputs():
                    if o in inputs:
                        label = " [ label = \"" + o + "\" ]"
                        out +=  x.myName + " -> " + c.myName + label + ";\n"
        return out

    def returnOutput(self, targetfd):
        # if we have an output...
        if not self.fileMap.has_key(ScriptingEnv.SCRIPT_OUTFILE):
            return  # already returned console out during exec.

        oname = self.fileMap[ScriptingEnv.SCRIPT_OUTFILE][1]

        if(local.disableHTTP):
            self.rawWrite(oname, targetfd)
        else:
            self.httpWrite(oname, targetfd)
        pass

    def rawWrite(self, srcfilename, targetfd):
        result = open(srcfilename)
        shutil.copyfileobj(result, targetfd)
        result.close()
    def httpWrite(self, srcfilename, targetfd):
        print >> targetfd, "HTTP/1.0 200 OK"
        print >> targetfd, "Xssdap-server: 0.1"
        print >> targetfd, "Date: " + time.ctime()
        print >> targetfd, "Content-type: application/x-netcdf"
        print >> targetfd, ""
        self.rawWrite(srcfilename, targetfd)
    def clearTemps(self):
        #logit("tempdir is " + str(os.listdir(self.env["tempdir"])))
        for key in self.fileMap:
            # if the file exists, and we can write it,
            # kill it to clean up.
            (fd,fname) = self.fileMap[key]
            if os.access(fname, os.F_OK | os.W_OK):
                os.remove(fname)
            else:
                logit("I couldn't delete " + str(fname))
        pass
    def fingerprint(self):
        try: return self.cachedFingerprint
        except:
            import md5
            script = "".join(self.lines)
            self.cachedFingerprint = md5.md5(script).digest()
            return self.cachedFingerprint
        pass



    def __del__(self):
        """some cleanup for the scripting environment"""
        ## we should get rid of temp files, like a good citizen
        ## this might be modified if we introduce caching
        self.clearTemps()
    pass



class FrontEnd:
    # put in url .../foo.nc.dods?superduperscript11"
    MAGIC_CONSTRAINT = "superduperscript11"
    # use in script to indicate what file should be sent back.

    def __init__(self, sysargs):
        # -d and -f options are supposed to be deprecated
        self.shortopts = "Lcd:r:o:e:f:l:u:v:"
        self.args = {}
        self.originalargs = sysargs
        self.env = {}
        #print sys.argv

        parsed =  getopt.getopt(sysargs[1:], self.shortopts)
        self.nonpars = []
        self.newp = []
        if parsed[1] != []:
            #logit( "nonparseable avail."+str(parsed[1]))
            nonpars = parsed[1][0]
            newp = getopt.getopt(parsed[1][1:],self.shortopts)
            newp = newp[0]
        else:
            nonpars = ""
            newp = []

        for i in parsed[0]:
            #print i
            #logfile.write(str(i)+"\n")
            self.args[i[0]] = i[1]
        #print " and fixed is ", nonpars
        #logfile.write(str(nonpars)+"\n")
        self.args["-realfile"] = nonpars

        for i in newp:
            #print i
            #logfile.write(str(i)+"\n")
            self.args[i[0]] = i[1]
        #print self.args

        #logit( str(self.args))
#       for x in  os.environ: #.get("LD_LIBRARY_PATH")
    #       print x

        pass
    def accessmode(self):
        if "-o" not in self.args:
            return "helpmode"
        return self.args["-o"]
    def passthrough(self):
        """ this should bounce the call to the default opendap netcdf handler"""
        newargs = [local.passthroughPath] + self.originalargs[1:]
        newline = ""
        ## need to substitute null strings to provide null -e option
        for x in newargs:
            if x == "": newline += "\"\" "
            else: newline += x + " "
        logit( "Bouncing from: " + str(self.originalargs[0]))
        logit( "Executing: " + newline)
        (sin,sout) = os.popen2(newline)
        # copy our stdin to the process
#       if sys.stdin.isatty():
#           shutil.copyfileobj(sys.stdin, sin)
        shutil.copyfileobj(sout, sys.stdout)

    def argReport(args):
        report = ""
        report += "scratch space loc(-r): " + self.args["-r"] + "\n"
        report += "originalurl(-u): " + self.args["-u"] + "\n"

        report += "realfile? " + self.args["-realfile"] + "\n"
        report += "compression? " + ["nope","requested"][bool(self.args.has_key("-c"))] + "\n"
        report += "requestor: " + self.args["-v"] + "\n"
        if "-e" in self.args:
            report += "constraint: " + self.args["-e"] + "\n"
        else: report += "constraint: no\n"
        return report

    def runhacked(self):
        """this is where we should go ahead and run the script that we got passed."""

        if "-e" in self.args:
            if "-u" not in self.args:
                self.passthrough()
                return
            else:
                # logit(argReport(self.args))
                if self.args["-e"] == FrontEnd.MAGIC_CONSTRAINT:
                    #logit("stdin = tty?" + str(sys.stdin.isatty()))
                    self.readScript()
                    self.runScript()
                    return
        self.passthrough()  ## passthrough everything else.

    def printusage(self):
        print """
        This script is to be called by an opendap
        installation.  Ask a developer for more info."""



    def execute(self):
        jumptable={'dods' : self.runhacked,
               'DODS' : self.runhacked,
               'das' :  self.passthrough,
               'DAS' :  self.passthrough,
               'dds' :  self.passthrough,
               'DDS' :  self.passthrough,
               'DDX' :  self.passthrough,
               'BLOB':  self.passthrough,
               'Version': self.passthrough,
               'helpmode': self.printusage
               }
        jumptable[self.accessmode()]()  ## make the call
        pass
    def readScript(self):
        """ reads in stdin as script input"""
        lines = []
        for i in sys.stdin:
            lines += [i] ## [] to put lines (not chars) in the list

        #logit( "we got POST data: \n"+str(lines))
        self.scriptlines = lines
        pass
    def runScript(self):
        self.env["tempdir"] = self.args["-r"]
        (filepath, filename) = os.path.split(self.args["-realfile"])

        self.env["defpath"] = filepath # use for default path.
        self.env["requestedfile"] = filename  #not sure we need this

        (urlpath, ufilename) = os.path.split(self.args["-u"])
        assert filename == ufilename
        for x in range(1,len(filepath)):
            pass

        #self.env["local"] = "true"
        scriptenv = ScriptingEnv(self.scriptlines, self.env)
        scriptenv.execute() #####
        #print "Skipping real execution for now"
        scriptenv.returnOutput(sys.stdout)
        pass


class JobManager:  # will I have to write this?
    def __init__(self):
        self.maxParallel = 2


prestartLogging()
readConfigFile() # have to read config file before initializing logging.
startLogging()
settings = FrontEnd(sys.argv)

mode =  settings.accessmode()
logit("Mode is " + mode)

settings.execute()


logit("handler hack log closed at " + time.ctime()+ "\n")

#########################################
# notes for adding async support
#########################################
# usage model:
#
# initial script submission
# blah -c -h somefile somefile
# blah blah blah
# blah blah blah
# %async%
#
# The server should respond with something like
# 5 jobs submitted, your job id: 200
# %async-resp% yourhost, url, 5, 200
#
#234567890123456789012345678901234567890123456789012345678901234567890123456789
#0       1         2         3         4         5         6         7
#


