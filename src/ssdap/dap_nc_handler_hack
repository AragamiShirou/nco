#!/usr/bin/env python
import getopt, os, sys, tempfile, shutil
import string, time

# $Id: dap_nc_handler_hack,v 1.4 2006-01-31 02:56:27 wangd Exp $
# This is:  -- a wrapper-replacement for dap_nc_handler used by opendap.
#           -- It provides a script handling facility, but redirects most
#              normal calls to the original dap_nc_handler

# we potentially have to handle: das, dds, dods, ascii, info
# das -- ??
# dds -- ??
# dods -- return dods data. This is the one we care about.
# ascii -- does dods mode, with -e and no url
# info -- does das/dds sequence
# html -- calls das/dds to obtain var info, then gives html form
# version -- doesn't seem to call the handler: opendap core version

#options: -o <response>: DAS, DDS, DataDDS, DDX, BLOB or Version (Required)
#          -u <url>: The complete URL minus the CE (required for DDX)
#          -c: Compress the response using the deflate algorithm.
#          -e <expr>: When returning a DataDDS, use <expr> as the constraint.
#          -v <version>: Use <version> as the version number
#          -d <dir>: Look for ancillary file in <dir> (deprecated).
#          -f <file>: Look for ancillary data in <file> (deprecated).
#          -r <dir>: Use <dir> as a cache directory
#          -l <time>: Conditional request; if data source is unchanged since
#                     <time>, return an HTTP 304 response.
#
#          -L : skip printing of http headers. **** for easier testing

#

######################################################################
# Administrator-tunable parameters:
######################################################################
class local:
	disableLogging = False
	logLocation = "/home/wangd/opendap/iroot/hackscr.log"

	#ncBinPath = os.environ["MY_BIN_DIR"] 
	ncBinPath = "/home/wangd/nco/nco/bin"

	# pass original DAP commands to the original dap handler.
	passthroughPath = "/home/wangd/opendap/iroot/bin/dap_nc_handler"


######################################################################

# setup some logging
if not local.disableLogging:
	local.logfile = open(local.logLocation, "a")
	local.logfile.write("handler hack log open at " + time.ctime()+"\n")
	
def logit(s):
	if not local.disableLogging:
		local.logfile.write(s+"\n")
	#print s
def logflush():
	if not local.disableLogging:
		local.logfile.flush()
	pass

	

class ScriptingEnv:
	# constants (but not const-enforced by python)
	SCRIPT_OUTFILE = "%outfile%"
	NCBINPATH = local.ncBinPath
	NC_SUFFIX = ".nc"
	LOCALSWITCH = "local"
	NCO_COMMANDS = ["ncap", "ncatted", "ncbo", "ncdiff",
			"ncea", "ncecat", "ncflint", "ncks",
			"ncpack", "ncpdq", "ncra", "ncrcat",
			"ncrename", "ncunpack", "ncwa"]
	VALID_COMMANDS = {}
	for n in NCO_COMMANDS:
		VALID_COMMANDS[n] = (NCBINPATH + os.sep + n )
	# room to add other commands here.
       	
	
	COMMENT_CHAR = "#"  # not used right now.

	def __init__(self, scriptlines, settingsDict):
		assert type(scriptlines) == type([])
		assert type(settingsDict) == type({})
		self.fileMap = {}
		self.env = settingsDict
		self.lines = scriptlines
		self.makeCommandLine()
		pass

	## flexible result handling needs to be designed with
	## multiple script lines in mind.
	def getResultHandler(self, cmd):
		"""returns a function f that has args: (stdout, filename)
		"""
		return 

	def stdoutHandler(self, stdout, filename):
		pass
	def outfileHandler(self, stdout, filename):
		pass
	
	def shouldRemap(self, absName):
		# return bool indicating whether this word should be xlated.
		# keep simple for now: check a list.
		# suck class const into local namespace.
		return absName in [ScriptingEnv.SCRIPT_OUTFILE]
	def possibleFilename(self, cand):
		elts = string.split(cand, ".")

		if len(elts) != 2: #looking for something.ext
			return False
		if elts[1] != "nc": # only going to detect .nc
			return False
		if elts[0][0] == os.sep: # do not detect with leading /
			return False
		return True
	
	
	def addAbsName(self, absName):
		""" return a concrete name from an abstract name"""
		if self.fileMap.has_key(absName):
			return None # can't assign name, already assigned!
		alnum = string.letters + string.digits
		fixName = ""
		for i in absName:
			if i in alnum: fixName += i

		filepair = tempfile.mkstemp( ScriptingEnv.NC_SUFFIX,
					    fixName,
					    self.env["tempdir"] )
		# filepair = (descriptor, tempfilename)
		self.fileMap[absName] = filepair
		# close the file, so the nco util can touch it
		os.close(filepair[0])
		return filepair[1]
	
	def makeCommandLine(self):
		newCommandLine = ""
		index = 0
		self.cmd = None 

		# for now, use only the first line
		for word in self.lines[0].split():
			if index is 0:
				if word in ScriptingEnv.VALID_COMMANDS:
					newCommandLine += " " + ScriptingEnv.VALID_COMMANDS[word]
					self.cmd = word
				else:
					handleError("unrecognized command:"
						    + word + " in script.")
					return # shouldn't continue
					
			elif self.shouldRemap(word):
				remapped = self.addAbsName(word)
				assert remapped != None
				newCommandLine += " " + remapped
			elif self.possibleFilename(word):
				newname = self.env["defpath"] + os.sep + word
				newCommandLine += " " + newname
			else: # passthrough unrecognized things
				newCommandLine += " " + word
			index = index + 1
			
		# chop off leading " "
		assert newCommandLine[0] == " " 
		newCommandLine = newCommandLine[1:]
		# proclaim my results
		logit( "real cmdline: " + newCommandLine)
		self.commandLine = newCommandLine
	def execute(self):
		self.clearTemps()
		logflush()
				
		(sin,sout) = os.popen2(self.commandLine)
		sin.close() # close the input, so it flushes
		#out handle is now ready to be read.
		for x in sout:
			logit( "execution output: " + x)
			pass
		# for now, ignore stdout
		#okay
		pass
	def returnOutput(self, targetfd):
		oname = self.fileMap[ScriptingEnv.SCRIPT_OUTFILE][1]
		
		if(ScriptingEnv.LOCALSWITCH in self.env):
			self.rawWrite(oname, targetfd)
		else:
			self.httpWrite(oname, targetfd)
		pass

	def rawWrite(self, srcfilename, targetfd):
		result = open(srcfilename)
		shutil.copyfileobj(result, targetfd)
		result.close()
	def httpWrite(self, srcfilename, targetfd):
		print >> targetfd, "HTTP/1.0 200 OK"
		print >> targetfd, "Xssdap-server: 0.1"
		print >> targetfd, "Date: " + time.ctime()
		print >> targetfd, "Content-type: application/x-netcdf"
		print >> targetfd, ""
		self.rawWrite(srcfilename, targetfd)
	def clearTemps(self):
		#logit("tempdir is " + str(os.listdir(self.env["tempdir"])))
		for key in self.fileMap:
			# if the file exists, and we can write it,
			# kill it to clean up.
			(fd,fname) = self.fileMap[key]
			if os.access(fname, os.F_OK | os.W_OK):
				os.remove(fname)
			else:
				logit("I couldn't delete " + str(fname))
		pass

	def __del__(self):
		"""some cleanup for the scripting environment"""
		## we should get rid of temp files, like a good citizen
		## this might be modified if we introduce caching
		self.clearTemps()
	pass


	
class Settings:
	# put in url .../foo.nc.dods?superduperscript11"
	MAGIC_CONSTRAINT = "superduperscript11"
	# use in script to indicate what file should be sent back.

	def __init__(self, sysargs):
		# -d and -f options are supposed to be deprecated
		self.shortopts = "Lcd:r:o:e:f:l:u:v:"
		self.args = {}
		self.originalargs = sysargs
		self.env = {}
		#print sys.argv

		parsed =  getopt.getopt(sysargs[1:], self.shortopts)
		self.nonpars = []
		self.newp = []
		if parsed[1] != []:
			#logit( "nonparseable avail."+str(parsed[1]))
			nonpars = parsed[1][0]
			newp = getopt.getopt(parsed[1][1:],self.shortopts)
			newp = newp[0]
		else:
			nonpars = ""
			newp = []
		#print "here it comes"
		for i in parsed[0]:
			#print i
			#logfile.write(str(i)+"\n")
			self.args[i[0]] = i[1]
		#print " and fixed is ", nonpars
		#logfile.write(str(nonpars)+"\n")
		self.args["-realfile"] = nonpars

		for i in newp:
			#print i
			#logfile.write(str(i)+"\n")
			self.args[i[0]] = i[1]
		#print self.args

		#logit( str(self.args))
#		for x in  os.environ: #.get("LD_LIBRARY_PATH")
	#		print x
	
		pass
	def accessmode(self):
		if "-o" not in self.args:
			return "helpmode"
		return self.args["-o"]
	def passthrough(self):
		""" this should bounce the call to the default opendap netcdf handler"""
		newargs = [local.passthroughPath] + self.originalargs[1:]
		newline = ""
		## need to substitute null strings to provide null -e option
		for x in newargs:
			if x == "": newline += "\"\" "
			else: newline += x + " "
		logit( "Bouncing from: " + str(self.originalargs[0]))
		logit( "Executing: " + newline)
		(sin,sout) = os.popen2(newline)
		# copy our stdin to the process
#		if sys.stdin.isatty():
#			shutil.copyfileobj(sys.stdin, sin)
		shutil.copyfileobj(sout, sys.stdout)

	def argReport(args):
		report = ""
		report += "scratch space loc(-r): " + self.args["-r"] + "\n"
		report += "originalurl(-u): " + self.args["-u"] + "\n"

		report += "realfile? " + self.args["-realfile"] + "\n"
		report += "compression? " + ["nope","requested"][bool(self.args.has_key("-c"))] + "\n"
		report += "requestor: " + self.args["-v"] + "\n"
		if "-e" in self.args:
			report += "constraint: " + self.args["-e"] + "\n"
		else: report += "constraint: no\n"
		return report

	def runhacked(self):
		"""this is where we should go ahead and run the script that we got passed."""
		
		if "-e" in self.args:
			if "-u" not in self.args:
				self.passthrough()
				return
			else:
				# logit(argReport(self.args))
				if self.args["-e"] == Settings.MAGIC_CONSTRAINT:
					logit("stdin = tty?" + str(sys.stdin.isatty()))
					self.readScript()
					self.runScript()
					return
		self.passthrough()  ## passthrough everything else.

	def printusage(self):
		print """
		This script is to be called by an opendap
		installation.  Ask a developer for more info."""
		
		

	def execute(self):
		jumptable={'dods' : self.runhacked,
			   'DODS' : self.runhacked,
			   'das' :  self.passthrough,
			   'DAS' :  self.passthrough,
			   'dds' :  self.passthrough,
			   'DDS' :  self.passthrough,
			   'DDX' :  self.passthrough,
			   'BLOB':  self.passthrough,
			   'Version': self.passthrough,
			   'helpmode': self.printusage
			   }
		jumptable[self.accessmode()]()  ## make the call
		pass
	def readScript(self):
		""" reads in stdin as script input"""
		lines = []
		for i in sys.stdin:
			lines += [i] ## [] to put lines (not chars) in the list
			
		#logit( "we got POST data: \n"+str(lines))
		self.scriptlines = lines
		pass
	def runScript(self):
		self.env["tempdir"] = self.args["-r"]
		(filepath, filename) = os.path.split(self.args["-realfile"])
		
		self.env["defpath"] = filepath # use for default path.
		self.env["requestefile"] = filename  #not sure we need this
		#self.env["local"] = "true"
		scriptenv = ScriptingEnv(self.scriptlines, self.env)
		scriptenv.execute()
		scriptenv.returnOutput(sys.stdout)
		pass
		


settings = Settings(sys.argv)
mode =  settings.accessmode()
logit("Mode is " + mode)

settings.execute()


logit("handler hack log closed at " + time.ctime()+ "\n")

